:page-title     : ELGamal
:page-signed-by : Deo Valiandro. M <valiandrod@gmail.com>
:page-layout    : default
:page-category  : Kriptografi
:page-tags      : [kripto, asimetris]
:page-desc      : ElGamal adalah asymmetric key encryption algorithm yang menggunakan persoalan logaritma diskrit, algoritma ini didasarkan pada Diffieâ€“Hellman key exchange.

== Pendahuluan

ElGamal dibuat oleh Taher Elgamal pada tahun 1985. Keamanan ElGamal terletak
pada persoalan logaritma diskrit, yaitu jika stem:[p \in \mathbb{P}, \{g, y\} \in \mathbb{Z}], maka temukan stem:[x: g^{x} \equiv y (\bmod p)].

== Variabel

. stem:[p \in \mathbb{P}] (tidak rahasia),
. stem:[]

== Fungsi Enkripsi dan Dekripsi

== Skenario

== Pembangkitan Kunci

== Enkripsi Pesan

== Dekripsi Pesan

== Penutup

== Reference

== Lampiran

Alice's key: private key = stem:[x], publick key = stem:[(y, g, p)]. Ciphertext = stem:[(a, b)].

usage: `python elgamal.py`

```python
def is_relative_prime(prime, data):
    while data != 0:
        prime, data = data, prime % data
    return prime

def is_primitive_root(prime, root):
    primitive_root = []
    for i in range(prime - 1):
        primitive_root.append(pow(root, i + 1) % prime)

    # Untuk memastikan tidak terjadi pembandingan primitive_root pada indeks j
    # dan i yang sama
    kampret = 1
    
    # Membandingkan apakah tidak ada data yang sama
    for i in range(len(primitive_root)):
        for j in range(kampret, len(primitive_root) - 1):
            if primitive_root[i] == primitive_root[j + 1]:
                print("Not primitive root")
                return 0

        if is_relative_prime(prime, primitive_root[i]) != 1:
            print("Not relative prime")
            return 0
        kampret += 1
    return 1


def key_builder():
    print("Input prime number, root and secret key (x)")
    prime, root, secret_key = [int(x) for x in input().split(" ")]

    # root number must be primitive root from prime
    if is_primitive_root(prime, root) == 1:
        y = pow(root, secret_key) % prime
        print(f"Public Key (%d, %d, %d)" % (y, root, prime))
        print(f"Private key %d" % secret_key)


def encryption():
    # message is one character, string will be add later
    print("Input message")
    message = input()

    print("Input y, g and p (public key)")
    y, g, p = [int(x) for x in input().split(" ")]

    # k is random number from 1 <= k <= p-1
    print("Input k")
    k = int(input())

    # the ciphertext will be a pair of a and b
    a = pow(g, k) % p
    b = (pow(y, k) * ord(message)) % p

    print(f"Ciphertext (%d, %d)" % (a, b))


def decryption():
    a, b, x, p = [int(x) for x in input().split(" ")]
    m = pow(a, (p-1-x)) * b % p
    print(f"Message %c" % m)

key_builder()
encryption()
decryption()
```