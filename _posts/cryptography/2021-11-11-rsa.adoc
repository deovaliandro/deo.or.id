= RSA
:page-category: cryptography

[.center]
_Deo Valiandro. M <valiandrod@gmail.com>_

== I. Pendahuluan

RSA adalah sebuah algoritma berdasarkan skema public-key cryptography.
Diberi nama RSA sebagai inisial para penemunya: _Ron Rivest_, _Adi Shamir_, dan
_Leonard Adleman_. RSA dibuat di MIT pada tahun 1977 dan dipatenkan oleh MIT
pada tahun 1983. Setelah bulan September tahun 2000, paten tersebut
berakhir, sehingga saat ini semua orang dapat menggunakannya dengan bebas.

RSA adalah algoritma yang mudah untuk diimplementasikan dan
dimengerti. Algoritma RSA adalah sebuah aplikasi dari sekian banyak teori
seperti extended Euclid algorithm, Euler's function sampai Fermat theorem. 

== II. Public-Key Cryptography

Konsep fundamental dari Public-Key Cryptography ditemukan oleh
_Whitfield Diffie_ dan _Martin Hellman_, dan secara terpisah oleh
_Ralph Merkle_.

Sedangkan konsep dasar Public-Key Cryptography terletak pada pemahaman 
bahwa keys selalu berpasangan: encryption key dan decryption key. Juga perlu
diingat bahwa sebuah key tidak dapat digenerate dari key lainnya. Pemahaman 
encryption dan decryption key sering disebut sebagai public dan private key.
Seseorang harus memberikan public key-nya agar pihak lain dapat meng-encrypt
sebuah pesan. Decryption hanya terjadi jika seseorang mempunyai private key.

Penggunaan algoritma ini harus memenuhi kriteria berikut.

. Memungkinkan untuk mencari nilai stem:[e], stem:[d], stem:[n] sedemikian rupa
sehingga stem:[M^e] atau stem:[M^d \mod n = M, \forall M < n].
. Relatif mudah untuk menghitung nilai stem:[M^e \mod n] dan stem:[C^d \mod n
\forall M < n].
. Tidak memungkinkan mencari nilai stem:[d] jika diberikan nilai stem:[n] dan
stem:[e].

Syarat nilai stem:[e] dan stem:[d] ini, stem:[gcd(d,e)=1].

Sebelum memulai penggunaan RSA ini, terlebih dahulu kita harus memiliki
bahan-bahan dasar sebagai berikut :

. stem:[p] dan stem:[q], 2 bilangan prima yang dirahasiakan
. stem:[n], dari hasil stem:[p \cdot q]
. stem:[e], dengan ketentuan stem:[gcd (\phi(n), e) = 1]
. stem:[d], stem:[e^-1 (\mod \phi(n))]

== Skenario

Bagian ini menjelaskan skenario bagaimana public-key cryptosystem bekerja.
Saya akan menggunakan partisipan klasik Alice dan Bob sebagai orang-orang
yang melakukan pertukaran informasi.

. Alice dan Bob setuju untuk menggunakan public-key cryptosystem.
. Bob mengirimkan public key-nya kepada Alice.
. Alice meng-encrypt pesan yang dibuatkan dengan menggunakan public key milik
Bob dan mengirimkan pesan yang sudah di-encrypt kepada Bob.
. Bob men-decrypt pesan dari Alice menggunakan private key miliknya.

== Rumus Dasar

Terdapat dua rumus utama dari RSA, yaitu :

[source, bash]
C = M^e mod n (fungsi enkripsi)
M = C^d mod n (fungsi dekripsi)

dimana:

- stem:[C] = Cipherteks
- stem:[M] = Message/plainteks
- stem:[e] = kunci publik
- stem:[d] = kunci privat
- stem:[n] = modulo pembagi (akan dijelaskan lebih lanjut)

== Key Generation

Misalkan Alice ingin Bob mengirimnya sebuah pesan melalui jalur yang aman.
Alice akan memberikan public keynya kepada Bob dan menyimpan private key
untuk dirinya.

. Pilih 2 bilangan prima, misalnya stem:[p = 17] dan stem:[q = 11].
. Hitung stem:[n = p \cdot q = 17 \times 11 = 187].
. Hitung stem:[\phi(n) = (p – 1)(q – 1) = 16 \times 10 = 160].
. Pilih nilai stem:[e] sedemikian sehingga relatif prima terhadap stem:[\phi(n)
= 160] dan kurang dari stem:[\phi(n)]; kita pilih stem:[e = 7].
. Hitung d sedemikian sehingga stem:[d \cdot e \equiv 1 (\mod 160)] dan
stem:[d < 160]. Nilai yang didapatkan stem:[d = 23],karena
stem:[23 \times 7 = 161 = (1 \times 160) + 1]; stem:[d] dapat dihitung dengan
_Extended Euclidean Algorithm_.

Nah, nilai e dan d inilah yang kita sebut sebagai _public key (e)_ dan _private
key (d)_.  Pasangan Kunci publiknya = stem:[{7,187}] dan kunci privatnya = 
stem:[{23, 187}]


== Encrypting Message

Misalkan Bob ingin mengirim sebuah pesan stem:[88] kepada Alice.

. Alice harus membuat keynya; sehingga ia memiliki private dan public keys.

[source, code]
private key = (M,d)
public key  = (M,e)

Untuk proses enkripsi, kita akan menghitung

[.center]
stem:[c = 88^7 \mod 187 = 40867559636992 \mod 187 = 11]

Nah, kita mendapatkan nilai stem:[c = 11].

Untuk melakukannya, kita dapat menggunakan python:

[source, python]
import math
c = pow(88, 7) % 187

Bob mengirimkan bilangan tersebut kepada Alice sehingga Alice dapat melakukan
dekripsi menggunakan private keynya.

== Decrypting Message

Misalkan Alice menerima sebuah pesan terencrypt yaitu stem:[11], ia akan mendecryptnya.

[.center]
stem:[m = 11^23 \mod 187 = 895430243255237372246531 \mod 187 = 88]

Alice menerima pesan yang telah didekripsi yaitu 88.

Untuk melakukannya, kita dapat menggunakan python:

[source, python]
import math
c = pow(11, 23) % 187

== Penutup

RSA merupakan contoh yang powerful dan cukup aman dari _public key cryptography_.
Berdasarkan matematika, proses yang digunakan berdasarkan fungsi-fungsi
_trap-door_ satu arah. Sehingga melakukan enkripsi dengan menggunakan public key
sangat mudah bagi semua orang, namun proses dekripsi menjadi sangat sulit.

Proses decryption sengaja dibuat sulit agar seseorang, walaupun menggunakan Cray
supercomputers dan ribuan tahun, tidak dapat mendecrypt pesan tanpa mempunyai
private key. 

Perlu diingat juga bahwa pemilihan stem:[p \cdot q = M] haruslah sebuah bilangan
yang sangat besar sehingga sulit dicari eksponen decoding-nya karena sulit
melakukan pemfaktoran bilangan prima.

== Reference

. Childs, Lindsay N. A Concrete Introduction to Higher Algebra. 
Undergraduate Texts in Mathematics. Springer-Verlaag: New York, 
2000.

. Schneier, B. Applied Cryptography, 2nd Ed. John Wiley & Sons, Inc:
Canada, 1996.

. Rivest R.L., Shamir A., Adleman L. "A Method for Obtaining Digital
Signatures and Public-Key Cryptosystems. MIT: Massachusetts. 1977.