= Finite State Machine
:page-category: article

== Finite Automata

> "One way to define a language is to construct an automatonâ€”a kind
> of abstract computer that takes a string as input and produces a
> yes-or-no answer. The language it defines is the set of all strings for
> which it says yes.
> 
> _Formal Language - A Practical Introduction by Adam Brooks Webber_

=== a. Deterministic Finite Automata (DFA)

DFA stem:[M = (Q, \Sigma, \delta, q_0, F)], dimana:

. stem:[Q] adalah set semua state (finite),
. stem:[\Sigma] adalah alfabet/ input (finite set symbols),
. stem:[\delta \in (Q xx \Sigma \to Q)] adalah fungsi transisi,
. stem:[q_0 \in Q] adalah start state,
. stem:[F \subseteq Q] adalah set state final (__accepting state__).

Contohnya: stem:[Q = {A, B}], stem:[\Sigma = {a, b}], stem:[F = {B}] dan
stem:[\delta] = +
stem:[\delta(A, a) = B] +
stem:[\delta(A, b) = A] +
stem:[\delta(B, a) = B] +
stem:[\delta(A, b) = A]

digambarkan dengan:

[#img-dfa] 
.A simple DFA
[link=/assets/img/Screenshot_20211204_211458.png]
image::/assets/img/Screenshot_20211204_211458.png[DFA]

String stem:[x \in \Sigma^{\ast}] akan di terima oleh DFA stem:[M = (Q, \Sigma,
\delta, q_0, F) \iff \delta^{\ast}(q_0, x) \in F].

Untuk DFA stem:[M = (Q, \Sigma, \delta, q_0, F)], stem:[L(M)] adalah language
yang bisa diterima oleh stem:[M], di mana stem:[L(M) = {x \in \Sigma^{\ast} |
\delta^{\ast}(q_0, x) \in F}].

Regular language adalah language yang diterima oleh sebuah finite automata, atau
sebuah regular language adalah stem:[L(M)] untuk suatu DFA stem:[M].

__Regular operation__ adalah operasi pada language. Misalnya A dan B adalah
language, maka operasinya:

. union, stem:[A \cap B = {x | x \in A or x \in B}],
. concatenation, stem:[A \cdot B = {xy | x \in A and y \in B}],
. star, stem:[A^{\ast} = {x_1 x_2 \cdots x_k | k \geq 0 \and, \forall x_i \in
A}].

Sifat rl:

. closed under complement, jika stem:[L] adalah language dari stem:[\Sigma],
maka komplemen dari stem:[L], stem:[\overline{L} = {x \in \Sigma^{\ast} | x
\notin L}], jika stem:[L] adalah regular language, maka stem:[\overline{L}] juga
adalah regular language.

. closed under intersection, jika stem:[L_1] dan stem:[L_2] adalah language,
intersection (irisan) dari stem:[L_1] dan stem:[L_2] adalah stem:[L_1 \cap L_2
= {x | x \in L_1 \and x \in L_2}], jika stem:[L_1] dan stem:[L_2] adalah
regular language, maka stem:[L_1 \cap L_2] juga adalah merupakan regular
language.

. closed under union, jika stem:[L_1] dan stem:[L_2] adalah language,
union (gabungan) dari stem:[L_1] dan stem:[L_2] adalah stem:[L_1 \cup L_2
= {x | x \in L_1 \or x \in L_2, \text{atau keduanya}}], jika stem:[L_1] dan
stem:[L_2] adalah regular language, maka stem:[L_1 \cup L_2] juga adalah
merupakan regular language.

=== b. Nondeterministic Finite Automata

NFA stem:[M = (Q, \Sigma, \delta, q_0, F)] dimana:

. stem:[Q] adalah set semua state (finite),
. stem:[\Sigma] adalah alfabet/ input (finite set symbols),
. stem:[\delta \in (Q xx (\Sigma \cup {\epsilon}) \to P(Q))] adalah fungsi
transisi,
. stem:[q_0 \in Q] adalah start state,
. stem:[F \subseteq Q] adalah set state final (__accepting state__).

Contohnya: stem:[Q = {q_0, q_1, q_2}], stem:[\Sigma = {a, b}], stem:[F = {q_2}]
dan stem:[\delta] = +
stem:[\delta(q_0, a) = {q_0, q_1}] +
stem:[\delta(q_0, b) = {q_0}] +
stem:[\delta(q_0, \epsilon) = {q_2}] +
stem:[\delta(q_1, a) = {}] +
stem:[\delta(q_1, b) = {q_2}] +
stem:[\delta(q_1, \epsilon) = {}] +
stem:[\delta(q_2, a) = {}] +
stem:[\delta(q_2, b) = {}] +
stem:[\delta(q_2, \epsilon) = {}]

digambarkan dengan:

[#img-nfa] 
.A simple NFA
[link=/assets/img/Screenshot_20211207_113854.png]
image::/assets/img/Screenshot_20211207_113854.png[NFA]

=== conver NFA to DFA

lorem


=== minimization of DFA

Myhill Nerode Theorem for minimization DFA

=== Regular Expression

=== Mealy and Moore Machine
==== convert Melay to Moore and the opposite

=== stem:[\epsilon] NFA
==== stem:[\epsilon] NFA to NFA

=== Nonregular Languages